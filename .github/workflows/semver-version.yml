name: Generate Semantic Version

on:
  workflow_call:
    inputs:
      prefix:
        description: "Optional prefix to prepend to generated tags (e.g., module names)"
        required: false
        type: string
        default: ""
      supress_release:
        description: "If true, skip creating a GitHub release"
        required: false
        type: boolean
        default: false
      supress_tag:
        description: "If true, skip creating a Git tag and release"
        required: false
        type: boolean
        default: false
      check_last_commit_only:
        description: "If true, only inspect the most recent commit when determining bump type"
        required: false
        type: boolean
        default: false
    outputs:
      version:
        description: "Calculated semantic version"
        value: ${{ jobs.bump.outputs.version }}
      tag:
        description: "Created tag name"
        value: ${{ jobs.bump.outputs.tag }}
      bump_type:
        description: "Type of bump applied (major, minor, patch)"
        value: ${{ jobs.bump.outputs.bump_type }}
      previous_tag:
        description: "Most recent tag prior to calculation (if any)"
        value: ${{ jobs.bump.outputs.previous_tag }}
      commit_subject:
        description: "Commit subject that drove the bump decision"
        value: ${{ jobs.bump.outputs.commit_subject }}

jobs:
  bump:
    name: Determine version and tag
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: read
    outputs:
      version: ${{ steps.compute.outputs.version }}
      tag: ${{ steps.compute.outputs.tag }}
      bump_type: ${{ steps.compute.outputs.bump_type }}
      previous_tag: ${{ steps.compute.outputs.previous_tag }}
      commit_subject: ${{ steps.compute.outputs.commit_subject }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Compute next version
        id: compute
        env:
          PREFIX: ${{ inputs.prefix }}
          CHECK_LAST_COMMIT_ONLY: ${{ inputs.check_last_commit_only }}
        shell: bash
        run: |
          set -eo pipefail

          prefix="${PREFIX:-}"
          check_last_commit_only="${CHECK_LAST_COMMIT_ONLY,,}"
          if [[ -n "$prefix" ]]; then
            tag_match="${prefix}-v*"
            prefix_with_dash="${prefix}-"
          else
            tag_match='v*'
            prefix_with_dash=""
          fi

          last_tag=$(git describe --tags --match "$tag_match" --abbrev=0 2>/dev/null || echo "")
          if [[ -z "$last_tag" ]]; then
            last_version="0.0.0"
          else
            stripped_tag="${last_tag#${prefix_with_dash}}"
            last_version="${stripped_tag#v}"
          fi

          IFS='.' read -r major minor patch <<< "$last_version"
          major=${major:-0}
          minor=${minor:-0}
          patch=${patch:-0}

          major_pattern='^[^[:space:]]*!:'
          minor_pattern='^feat(\([^)]*\))?:'

          if [[ "$check_last_commit_only" == "true" ]]; then
            if [[ -n "$last_tag" ]]; then
              mapfile -t commit_subjects < <(git log -1 --pretty=%s "${last_tag}..HEAD")
            else
              mapfile -t commit_subjects < <(git log -1 --pretty=%s)
            fi
          else
            if [[ -n "$last_tag" ]]; then
              mapfile -t commit_subjects < <(git log "${last_tag}..HEAD" --pretty=%s)
            else
              mapfile -t commit_subjects < <(git log --pretty=%s)
            fi
          fi

          highest_level=0
          commit_subject=""

          for subject in "${commit_subjects[@]}"; do
            [[ -z "$commit_subject" ]] && commit_subject="$subject"

            subject_lower=$(printf '%s' "$subject" | tr '[:upper:]' '[:lower:]')

            if [[ $subject =~ $major_pattern ]]; then
              highest_level=2
              commit_subject="$subject"
              break
            elif [[ $subject_lower =~ $minor_pattern ]]; then
              if (( highest_level < 1 )); then
                highest_level=1
                commit_subject="$subject"
              fi
            fi
          done

          if [[ ${#commit_subjects[@]} -eq 0 ]]; then
            commit_subject="No commits since last release"
            highest_level=0
          fi

          case $highest_level in
            2)
              major=$((major + 1))
              minor=0
              patch=0
              bump_type="major"
              ;;
            1)
              minor=$((minor + 1))
              patch=0
              bump_type="minor"
              ;;
            *)
              patch=$((patch + 1))
              bump_type="patch"
              ;;
          esac

          new_version="$major.$minor.$patch"
          new_tag="${prefix_with_dash}v${new_version}"

          printf 'bump_type=%s\n' "$bump_type" >> "$GITHUB_OUTPUT"
          printf 'previous_tag=%s\n' "$last_tag" >> "$GITHUB_OUTPUT"
          printf 'version=%s\n' "$new_version" >> "$GITHUB_OUTPUT"
          printf 'tag=%s\n' "$new_tag" >> "$GITHUB_OUTPUT"
          printf 'commit_subject=%s\n' "$commit_subject" >> "$GITHUB_OUTPUT"

          echo "Determined $bump_type bump from '$commit_subject' -> $new_tag"

      - name: Create and push tag
        if: ${{ inputs.supress_tag != true }}
        env:
          TAG_NAME: ${{ steps.compute.outputs.tag }}
        shell: bash
        run: |
          set -eo pipefail
          if git rev-parse -q --verify "refs/tags/${TAG_NAME}" >/dev/null; then
            echo "Tag ${TAG_NAME} already exists. Skipping creation."
            exit 0
          fi

          git tag "${TAG_NAME}" "${GITHUB_SHA}"
          git push origin "${TAG_NAME}"
          echo "Pushed tag ${TAG_NAME}"

      - name: Create GitHub release
        if: ${{ inputs.supress_tag != true && inputs.supress_release != true }}
        env:
          TAG_NAME: ${{ steps.compute.outputs.tag }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -eo pipefail

          if gh release view "${TAG_NAME}" >/dev/null 2>&1; then
            echo "Release ${TAG_NAME} already exists. Skipping creation."
            exit 0
          fi

          gh release create "${TAG_NAME}" \
            --title "${TAG_NAME}" \
            --target "${GITHUB_SHA}" \
            --generate-notes
          echo "Created release ${TAG_NAME}"
