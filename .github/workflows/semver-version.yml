name: Generate Semantic Version

on:
  workflow_call:
    inputs:
      prefix:
        description: "Optional prefix to prepend to generated tags (e.g., module names)"
        required: false
        type: string
        default: ""
      suppress_release:
        description: "If true, skip creating a GitHub release"
        required: false
        type: boolean
        default: false
      suppress_tag:
        description: "If true, skip creating a Git tag and release"
        required: false
        type: boolean
        default: false
      check_last_commit_only:
        description: "If true, only inspect the most recent commit when determining bump type"
        required: false
        type: boolean
        default: false
      is_prerelease:
        description: "If true, generate a prerelease version"
        required: false
        type: boolean
        default: false
      prerelease_name:
        description: "Name for prerelease identifier (e.g., 'prerelease', 'rc', 'alpha')"
        required: false
        type: string
        default: "prerelease"
    outputs:
      version:
        description: "Calculated semantic version"
        value: ${{ jobs.bump.outputs.version }}
      tag:
        description: "Created tag name"
        value: ${{ jobs.bump.outputs.tag }}
      bump_type:
        description: "Type of bump applied (major, minor, patch)"
        value: ${{ jobs.bump.outputs.bump_type }}
      previous_tag:
        description: "Most recent tag prior to calculation (if any)"
        value: ${{ jobs.bump.outputs.previous_tag }}
      commit_subject:
        description: "Commit subject that drove the bump decision"
        value: ${{ jobs.bump.outputs.commit_subject }}

jobs:
  bump:
    name: Determine version and tag
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: read
    outputs:
      version: ${{ steps.compute.outputs.version }}
      tag: ${{ steps.compute.outputs.tag }}
      bump_type: ${{ steps.compute.outputs.bump_type }}
      previous_tag: ${{ steps.compute.outputs.previous_tag }}
      previous_tag_for_changelog: ${{ steps.compute.outputs.previous_tag_for_changelog }}
      commit_subject: ${{ steps.compute.outputs.commit_subject }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          fetch-depth: 0

      - name: Compute next version
        id: compute
        env:
          PREFIX: ${{ inputs.prefix }}
          CHECK_LAST_COMMIT_ONLY: ${{ inputs.check_last_commit_only }}
          IS_PRERELEASE: ${{ inputs.is_prerelease }}
          PRERELEASE_NAME: ${{ inputs.prerelease_name }}
        shell: bash
        run: |
          set -eo pipefail

          prefix="${PREFIX:-}"
          check_last_commit_only="${CHECK_LAST_COMMIT_ONLY,,}"
          is_prerelease="${IS_PRERELEASE,,}"
          prerelease_name="${PRERELEASE_NAME:-prerelease}"

          if [[ -n "$prefix" ]]; then
            tag_match="${prefix}-v*"
            prefix_with_dash="${prefix}-"
          else
            tag_match='v*'
            prefix_with_dash=""
          fi

          # Get all tags matching the pattern
          if tag_output=$(git tag -l "$tag_match" --sort=-version:refname) && [[ -n "$tag_output" ]]; then
            mapfile -t all_tags <<< "$tag_output"
          else
            all_tags=()
          fi

          # Find the last stable version (no prerelease identifier)
          last_stable_tag=""
          last_stable_version="0.0.0"
          for tag in "${all_tags[@]}"; do
            stripped_tag="${tag#${prefix_with_dash}}"
            version="${stripped_tag#v}"
            # Check if this is a stable version (no dash in version)
            if [[ ! "$version" =~ - ]]; then
              last_stable_tag="$tag"
              last_stable_version="$version"
              break
            fi
          done

          # Parse the stable version for bump calculation
          IFS='.' read -r major minor patch <<< "$last_stable_version"
          major=${major:-0}
          minor=${minor:-0}
          patch=${patch:-0}

          major_pattern='^[^[:space:]]*!:'
          minor_pattern='^feat(\([^)]*\))?:'

          # Determine which commits to check based on mode
          if [[ "$check_last_commit_only" == "true" ]]; then
            if [[ -n "$last_stable_tag" ]]; then
              mapfile -t commit_subjects < <(git log -1 --pretty=%s "${last_stable_tag}..HEAD")
            else
              mapfile -t commit_subjects < <(git log -1 --pretty=%s)
            fi
          else
            if [[ -n "$last_stable_tag" ]]; then
              mapfile -t commit_subjects < <(git log "${last_stable_tag}..HEAD" --pretty=%s)
            else
              mapfile -t commit_subjects < <(git log --pretty=%s)
            fi
          fi

          highest_level=0
          commit_subject=""

          for subject in "${commit_subjects[@]}"; do
            [[ -z "$commit_subject" ]] && commit_subject="$subject"

            subject_lower=$(printf '%s' "$subject" | tr '[:upper:]' '[:lower:]')

            if [[ $subject =~ $major_pattern ]]; then
              highest_level=2
              commit_subject="$subject"
              break
            elif [[ $subject_lower =~ $minor_pattern ]]; then
              if (( highest_level < 1 )); then
                highest_level=1
                commit_subject="$subject"
              fi
            fi
          done

          if [[ ${#commit_subjects[@]} -eq 0 ]]; then
            commit_subject="No commits since last release"
            highest_level=0
          fi

          # Calculate the new stable version based on bump type
          case $highest_level in
            2)
              major=$((major + 1))
              minor=0
              patch=0
              bump_type="major"
              ;;
            1)
              minor=$((minor + 1))
              patch=0
              bump_type="minor"
              ;;
            *)
              patch=$((patch + 1))
              bump_type="patch"
              ;;
          esac

          target_base_version="$major.$minor.$patch"

          # Find the last prerelease for this target base version and name
          last_prerelease_tag=""
          last_prerelease_version="0"
          if [[ "$is_prerelease" == "true" ]]; then
            escaped_prerelease_name=$(printf '%s' "$prerelease_name" | sed 's/[].[*^$()+?{|\\]/\\&/g')
            for tag in "${all_tags[@]}"; do
              stripped_tag="${tag#${prefix_with_dash}}"
              version="${stripped_tag#v}"
              if [[ "$version" =~ ^([0-9]+\.[0-9]+\.[0-9]+)-${escaped_prerelease_name}\.([0-9]+)$ ]]; then
                base_version="${BASH_REMATCH[1]}"
                prerelease_number="${BASH_REMATCH[2]}"
                if [[ "$base_version" == "$target_base_version" ]]; then
                  last_prerelease_tag="$tag"
                  last_prerelease_version="$prerelease_number"
                  break
                fi
              fi
            done
          fi

          # Build the final version string and determine changelog base tag
          if [[ "$is_prerelease" == "true" ]]; then
            # Increment prerelease version
            prerelease_version=$((last_prerelease_version + 1))
            new_version="$major.$minor.$patch-${prerelease_name}.${prerelease_version}"
            # For prereleases, compare against the previous prerelease for this base version if present, otherwise last stable
            if [[ -n "$last_prerelease_tag" ]]; then
              changelog_base_tag="$last_prerelease_tag"
            else
              changelog_base_tag="$last_stable_tag"
            fi
          else
            new_version="$major.$minor.$patch"
            # For stable releases, always use the last stable tag
            changelog_base_tag="$last_stable_tag"
          fi

          new_tag="${prefix_with_dash}v${new_version}"

          printf 'bump_type=%s\n' "$bump_type" >> "$GITHUB_OUTPUT"
          printf 'previous_tag=%s\n' "$last_stable_tag" >> "$GITHUB_OUTPUT"
          printf 'previous_tag_for_changelog=%s\n' "$changelog_base_tag" >> "$GITHUB_OUTPUT"
          printf 'version=%s\n' "$new_version" >> "$GITHUB_OUTPUT"
          printf 'tag=%s\n' "$new_tag" >> "$GITHUB_OUTPUT"
          printf 'commit_subject=%s\n' "$commit_subject" >> "$GITHUB_OUTPUT"

          echo "Determined $bump_type bump from '$commit_subject' -> $new_tag"
          echo "Changelog will be generated from: ${changelog_base_tag:-initial commit}"

      - name: Write summary
        shell: bash
        env:
          VERSION: ${{ steps.compute.outputs.version }}
          TAG: ${{ steps.compute.outputs.tag }}
          BUMP_TYPE: ${{ steps.compute.outputs.bump_type }}
          PREVIOUS_TAG: ${{ steps.compute.outputs.previous_tag }}
          COMMIT_SUBJECT: ${{ steps.compute.outputs.commit_subject }}
        run: |
          set -eo pipefail

          previous="${PREVIOUS_TAG:-none}"
          commit="${COMMIT_SUBJECT:-No commits since last release}"

          {
            echo "### Semantic version summary"
            echo ""
            echo "- Version: \`${VERSION}\`"
            echo "- Tag: \`${TAG}\`"
            echo "- Bump type: \`${BUMP_TYPE}\`"
            echo "- Previous tag: \`${previous}\`"
            echo "- Commit: ${commit}"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Create and push tag
        if: ${{ inputs.suppress_tag != true }}
        env:
          TAG_NAME: ${{ steps.compute.outputs.tag }}
        shell: bash
        run: |
          set -eo pipefail
          if git rev-parse -q --verify "refs/tags/${TAG_NAME}" >/dev/null; then
            echo "Tag ${TAG_NAME} already exists. Skipping creation."
            exit 0
          fi

          git tag "${TAG_NAME}" "${GITHUB_SHA}"
          git push origin "${TAG_NAME}"
          echo "Pushed tag ${TAG_NAME}"

      - name: Create GitHub release
        if: ${{ inputs.suppress_tag != true && inputs.suppress_release != true }}
        env:
          TAG_NAME: ${{ steps.compute.outputs.tag }}
          CHANGELOG_BASE_TAG: ${{ steps.compute.outputs.previous_tag_for_changelog }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          IS_PRERELEASE: ${{ inputs.is_prerelease }}
        shell: bash
        run: |
          set -eo pipefail

          if gh release view "${TAG_NAME}" >/dev/null 2>&1; then
            echo "Release ${TAG_NAME} already exists. Skipping creation."
            exit 0
          fi

          is_prerelease="${IS_PRERELEASE,,}"

          # Build the release command with conditional notes-start-tag
          release_args=(
            "${TAG_NAME}"
            --title "${TAG_NAME}"
            --target "${GITHUB_SHA}"
            --generate-notes
          )

          # Add prerelease flag if needed
          if [[ "$is_prerelease" == "true" ]]; then
            release_args+=(--prerelease)
          fi

          # Add notes-start-tag if there's a previous tag for changelog
          if [[ -n "$CHANGELOG_BASE_TAG" ]]; then
            release_args+=(--notes-start-tag "$CHANGELOG_BASE_TAG")
            echo "Generating release notes from ${CHANGELOG_BASE_TAG} to ${TAG_NAME}"
          else
            echo "Generating release notes from initial commit to ${TAG_NAME}"
          fi

          gh release create "${release_args[@]}"
          echo "Created release ${TAG_NAME}"
